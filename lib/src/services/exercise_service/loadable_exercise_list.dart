import '../../models/exercise.dart';
import 'exercise_loader/_exercise_loader.dart';

class LoadableExerciseList {
  Map<String, Future<Exercise?>> _loadingExercises = {};

  /// Ensures exercises can be loaded from a variety of sources into Mossy Vibes.
  ///
  /// This class is always used in conjunction with the `ExerciseService`. It
  /// ensures that the different ways an exercise might be loaded are handled
  /// gracefully, and that any methods that fail can be augmented with backup
  /// loading systems.
  ///
  /// In most cases, exercises are
  LoadableExerciseList();

  /// Retrieve all of the exercises that have been loaded by this class
  Future<List<Exercise>> get exercises async {
    final exercisesOrNull =
        await Future.wait(_loadingExercises.values.toList());

    final List<Exercise> out = [];
    for (var ex in exercisesOrNull) {
      if (ex != null) {
        out.add(ex);
      }
    }

    return out;
  }

  /// Add a new exercise that will need to be loaded
  ///
  /// This function allows for different loaders for the same exercise to be
  /// chained together, in order to have backup retrieval methods if one of
  /// the early loaders fails. The first loader to return a value in this chain
  /// will always be returned, and subsequent loaders will not be evaluated.
  ///
  /// Generally, loaders will be added to the tail of the list, only being
  /// retrieved if other methods fail to load content. However, in some cases,
  /// a loader should take precendence over all of its siblings. In this case,
  /// the loader can be added with the [evalFirst] argument, which will insert
  /// the specified loader at the beginning of the evaluation chain, rather than
  /// the end. This is useful in cases like local testing, where locally bundled
  /// files may be more up to date than their remote counterparts.
  ///
  /// If multiple loaders specify that they should [evalFirst], the most
  /// recently added loader will actually evaluate first.
  add(ExerciseLoader loader, {bool evalFirst = false}) {
    final curLoader = _loadingExercises[loader.exerciseId];

    // If we don't have a current loader, this loader becomes the first
    if (curLoader == null) {
      _loadingExercises[loader.exerciseId] = loader.load();

      // If this loader should be evaluated before any of it's sibling loaders,
      // insert it into the first link of the loader chain.
    } else if (evalFirst) {
      _loadingExercises[loader.exerciseId] =
          loader.load().then((Exercise? ex) async => ex ?? await curLoader);

      // If this loader should be evaluated only if its siblings fail, insert
      // it into the last link of the loader chain
    } else {
      _loadingExercises[loader.exerciseId] =
          curLoader.then((Exercise? ex) async => ex ?? await loader.load());
    }
  }

  /// Adds a set of exercises that need to be loaded to our loading chain
  ///
  /// Lists generated via `[ExerciseLoader].loadList` can be passed directly
  /// into this method (after the `Future` has resolved), in order to add all
  /// of the loaders generated by the classes themselves.
  ///
  /// Like [add], a caller can specify that all of the loaders in this list
  /// should be evaluated before their siblings via the [evalFirst] argument.
  /// See the details for [add] for more context on when and why that might be
  /// required.
  addAll(List<ExerciseLoader> loaders, {bool evalFirst = false}) {
    for (var loader in loaders) {
      add(loader, evalFirst: evalFirst);
    }
  }
}
